# 프로세스와 스레드

## 프로세스(Process)
> 프로그램을 `메모리 상에서 실행중인 작업`
> 프로세스는 실행중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는 것을 말한다.
> 운영체제로 부터 주소공간, 파일, 메모리 등을 할당 받음

## 스레드(Thread)
> 프로세스 안에서 실행되는 여러 흐름의 단위로 프로세스 내의 주소 공간이나 자원을 `공유`
> 스레드 ID, 프로그램 카운터, 레지스터 집합, 스택으로 구성됨
> 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 열린 파일이나 신호와 같은 운영체제 자원들을 공유

기본적으로 각 프로세스는 최소 1개의 스레드를 소유한다

[![](./images/process.png?width=500px)]()

**프로세스는 각각 별도의 주소공간을 할당받는다 `(독립적)`**
* Code : 코드 자체를 구성하는 메모리 영역(프로그램 명령)
* Data : 전역변수, 정적변수, 배열 등
    * 초기화 된 데이터 : data영역에 저장
    * 초기화 되지 않은 데이터 : bss(block started by symbol) 영역에 저장
* Heap : 동적 할당 시 사용(new(), malloc())
* Stack : 지역변수, 매개변수, 리턴 값(임시메모리 영역)
  

### 스레드(Thread)마다 스택(stack)을 독립적으로 할당받는 이유
스택은 함수 호출시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간으로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것. -> `독립적인 실행 흐름이 추가된다`(Thread가 하는 일)

## 프로세스와 스레드의 차이점 
프로세스는 자신만의 고유한 공간과 자원을 할당받아 사용하지만, 스레드는 다른 스레드와 공간과 자원을 공유하면서 사용한다  


## 멀티 프로세스
> 하나의 프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 `병렬적`으로 작업을 수행하는 것
**장점** : 안전성(메모리 침범 문제를 OS차원에서 해결)
**단점** : 각각 독립된 메모리 영역을 갖고 있어, 작업량이 많을수록 오버헤드가 발생, Context Switching으로 인한 성능저하

### :pushpin: Context Switching이란?
- **프로세스의 상태 정보를 저장하고 복원하는 일련의 과정**
- 즉, 동작 중인 프로세스가 대기하면서 해당 프로세스의 상태를 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 보관했던 프로세스 상태를 복구하는 과정을 말한다.
- 프로세스는 각 독립된 메모리 영역을 할당받아 사용되므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행되었을 때 오버헤드가 발생할 문제가 존재  

[![](./images/os_img2.PNG?width=500px)]()  

#### Context Switching 과정
- Task의 대부분 정보는 Register에 저장되고 PCB로 관리된다.
- 현재 실행하고 있는 Task의 PCB 정보를 저장한다.
- 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행할 수 있다.
  
## 멀티 스레드
> 하나의 응용프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것
> 스레드 들이 공유 메모리를 통해 다수의 작업을 동시에 처리하도록 해준다
**장점** : 독립적인 프로세스에 비해 공유 메모리만큼의 시간과 자원 손실이 감소,  전역 변수와 정적 변수에 대한 자료 공유 가능
**단점** : 안전성 문제. 하나의 스레드가 데이터 공간을 망가뜨리면 모든 스레드가 작동 불능 상태(공유 메모리를 갖기 때문)

### 멀티 스레딩의 문제점
서로 다른 스레드가 데이터와 힙 영역을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다.  
**그래서 멀티스레딩 환경에서는 동기화 작업이 필요하다.** 동기화를 통해 작업 처리 순서를 컨트롤하고 공유 자원에 대한 접근을 컨트롤 하는 것이다.  
But, 이로 인한 `병목현상`이 발생하여 성능이 저하될 가능성이 높다. 따라서 과도한 락으로 인한 병목현상을 줄여야 한다.
* 멀티스레드의 안전성에 대한 문제점은 `Critical Section`기법으로 대비 가능  

#### :pushpin: Critical Section
병렬 프로그래밍에서 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원을 접근하는 명령문 또는 코드의 일부 영역을 말한다. 
병렬 프로그래밍에서 스레드가 공유데이터 값을 변경하는 시점에 다른 스레드가 그 값을 읽으려할 때 발생하는 문제를 해결하기 위해 반드시 `동기화 처리(synchronized)`를 해줘야한다.  
임계구역에서 실행되는 스레드는 lock을 획득한다. 이 lock은 오직 하나의 스레드만 가진다.
**조건 3가지**
* 상호 배제
* 진행
* 한정된 대기  
  
  
# :question: 예상 질문
- 프로세스와 스레드의 차이점이 대해 설명해주세요.
- 멀티프로세스의 장단점에 대해서 설명해주세요.
- Context Switching에 대해 설명해주세요.
- 멀티스레드의 장단점에 대해 설명해주세요. -> 병목현상을 해결하기 위한 방법이 있을지 생각해보셨나요?

# :newspaper: Reference
[Context Switching](https://velog.io/@jaeyunn_15/CS-Context-Switching)
[Critical Section](https://hun-developer.tistory.com/36)